#include "conveyor.h"
/* Конвейер:
 * концепция разбития исполнения инструкций кода на этапы (извлечение инструкции, ее декодирование,
 * извлечение операндов, вычисление инструкции и запись результата в память (кэш)) с последующим возможным одновременным
 * исполнением различных этапов - например, во время обсчета инструкции на АЛУ возможен запрос следующей команды
 * и так далее.
 *
 * Цель конвейера - оптимизировать утилизацию ресурсов процессора и шины; например, если есть большое количество АЛУ
 * и мы хотим загрузить всех их работой, узким местом является шина - АЛУ не хватает инструкций и операндов для того,
 * чтобы приступить к работе.
 *
 * Здесь написана симуляция конвейера - его деятельность не отражается прямо на симуляции ПДП, скорее просто ведется подсчет,
 * насколько работа конвейера "помогла" оптимизации - за какое среднем число "тактов" исполняется программа с применением технологии
 * конвейера.
 *
 * Как устроена симуляция конвейера: этот класс отслеживает запросы к памяти на чтение/запись и запросы на исполнение инструкций на АЛУ
 * посредством вызовов соответствующих методов конвейера. С помощью этой информации он поддерживает модель конвейера.
 *
 * Модель конвейера: предполагаем, что в нашей системе (на плате, на кристалле, в чипе) есть n ALU и одна шина. Ограничим также количество
 * инструкций, с которыми одновременно работает конвейер до m. Каждая инструкция должна пройти пять этапов конвейера (с некоторыми исключениями,
 * для которых некоторые этапы пропускаются). Исполнение каждого этапа каждой инструкции занимает определенное число "тактов" - именно усреднение
 * этой величины мы и будем сравнивать при наличии конвейера (m отлично от 1) и без оного (1 "лента" конвейера - при этом и АЛУ, по существу, один).
 *
 * Проследим работу конвейера с инструкцией и из этого выведем подходящую реализацию его модели. Инструкция поступает в модель в момент извлечения
 * кода инструкции по адресу PC из памяти. Соответственно, в этот момент конвейер должен создавать объект, соответствующий этой инструкции, заполнять
 * поля этого объекта и говорить, что первый этап конвейера для этой инструкции исполнен. При записи в память результата исполнения инструкции конвейер
 * должен удалять эту инструкцию из своей модели.
 *
 * Рассмотрим теперь состояние модели - на конвейере несколько инструкций, возможно на различных этапах. Будем симулировать работу конвейера "прыжками
 * во времени" - в объекте конвейера поддерживается текущее число тактов и при попытке продвижения он ищет самую ближайшую точку во времени (такт),
 * когда произойдет перемена состояния конвейера - то есть, какая-то инструкция перейдет на следующий этап/освободит нить конвейера.
 *
 * Получаем, что конвейер должен уметь быстро находить следующую точку прыжка во времени (скорость не критична, но неплохо бы). Соответственно,
 * 1) из объекта инструкции в модели мы должны уметь понять, на каком она этапе, когда этот этап начался и когда он закончится (или сколько он длится.
 *    Эту информацию будет предоставлять VCPU при вызове методов конвейера на добавление команды)
 * 2) инструкции в модели должны храниться так, чтобы мы более-менее оптимально могли найти нужный скачок
 * 3) вопрос: когда и как должен продвигаться конвейер? Ответ: в моменты вызова метода добавления команды конвейер должен произвести такое количество
 *    скачков, чтобы свежая команда встала на конвейер.
 * 4) из работы VCPU с операндами для нас представляет интерес лишь структура операндов - сколько происходит разыменований и обращений к памяти (шине)
 *    на соответствующих этапах. Информация об операндах поступает в другом вызове нежели добавление команды. (DISCUSS: или поступает в том же? То есть,
 *    можно это делать получестно - VCPU фетчит инструкцию и операнды и только затем говорит конвейеру че да как. В такой реализации VCPU заполняет
 *    промежуточную структуру/объект, которую и передаст затем конвейеру)
 * */
conveyor::conveyor()
{

}
