#include "conveyor.h"
/* Конвейер:
 * концепция разбития исполнения инструкций кода на этапы (извлечение инструкции, ее декодирование,
 * извлечение операндов, вычисление инструкции и запись результата в память (кэш)) с последующим возможным одновременным
 * исполнением различных этапов - например, во время обсчета инструкции на АЛУ возможен запрос следующей команды
 * и так далее.
 *
 * Цель конвейера - оптимизировать утилизацию ресурсов процессора и шины; например, если есть большое количество АЛУ
 * и мы хотим загрузить всех их работой, узким местом является шина - АЛУ не хватает инструкции и операндов для того,
 * чтобы приступить к работе.
 *
 * Здесь написана симуляция конвейера - его деятельность не отражается прямо на симуляции ПДП, скорее просто ведется подсчет,
 * насколько работа конвейера "помогла" оптимизации - за какое среднем число "тактов" исполняется программа с применением технологии
 * конвейера.
 *
 * Как устроена симуляция конвейера: этот класс отслеживает запросы к памяти на чтение/запись и запросы на исполнение инструкций на АЛУ
 * посредством вызовов соответствующих методов конвейера. С помощью этой информации он поддерживает модель конвейера.
 *
 * Модель конвейера: предполагаем, что в нашей системе (на плате, на кристалле, в чипе) есть n ALU и одна шина. Ограничим также количество
 * инструкций, с которыми одновременно работает конвейер до m. Каждая инструкция должна пройти пять этапов конвейера (с некоторыми исключениями,
 * для которых некоторые этапы пропускаются). Исполнение каждого этапа каждой инструкции занимает определенное число "тактов" - именно усреднение
 * этой величины мы и будем сравнивать при наличии конвейера (m отлично от 1) и без оного (1 "лента" конвейера - при этом и АЛУ, по существу, один).
 *
 * Проследим работу конвейера с инструкцией и из этого выведем подходящую реализацию его модели. Инструкция поступает в модель в момент извлечения
 * кода инструкции по адресу PC из памяти. Соответственно, в этот момент конвейер должен создавать объект, соответствующий этой инструкции, заполнять
 * поля этого объекта и говорить, что первый этап конвейера для этой инструкции исполнен. При записи в память результата исполнения инструкции конвейер
 * должен удалять эту инструкцию из своей модели.
 *
 * Рассмотрим теперь состояние модели - на конвейере несколько инструкций, возможно на различных этапах. Будем симулировать работу конвейера "прыжками
 * во времени" - в объекте конвейера поддерживается текущее число тактов и при попытке продвижения он ищет самую ближайшую точку во времени (такт),
 * когда произойдет перемена состояния конвейера - то есть, какая-то инструкция перейдет на следующий этап/освободит нить конвейера.
 * */
conveyor::conveyor()
{

}
